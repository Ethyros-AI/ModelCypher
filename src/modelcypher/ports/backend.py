# Copyright (C) 2025 EthyrosAI LLC / Jason Kempf
#
# This file is part of ModelCypher.
#
# ModelCypher is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ModelCypher is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with ModelCypher.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

from typing import Any, Callable, Protocol, TypeVar, runtime_checkable

# TypeVar for array types - provides documentation and enables future typing improvements
# while remaining compatible with MLX arrays, NumPy ndarrays, and other backends.
# Using TypeVar instead of Any signals that these are homogeneous array operations.
Array = TypeVar("Array")


@runtime_checkable
class Backend(Protocol):
    """
    Abstract backend protocol for tensor operations.

    Implementations: MLXBackend (macOS), CUDABackend (Linux), NumpyBackend (tests).
    Domain classes should depend on this protocol, not concrete backends.
    """

    # --- Array Creation ---
    def array(self, data: Any, dtype: Any | None = None) -> Array: ...
    def zeros(self, shape: tuple[int, ...], dtype: Any | None = None) -> Array: ...
    def ones(self, shape: tuple[int, ...], dtype: Any | None = None) -> Array: ...
    def eye(self, n: int, m: int | None = None, dtype: Any | None = None) -> Array: ...
    def arange(
        self,
        start: int | float,
        stop: int | float | None = None,
        step: int | float = 1,
        dtype: Any | None = None,
    ) -> Array: ...
    def diag(self, array: Array, k: int = 0) -> Array: ...
    def full(
        self, shape: tuple[int, ...], fill_value: float, dtype: Any | None = None
    ) -> Array: ...
    def ones_like(self, array: Array, dtype: Any | None = None) -> Array: ...
    def zeros_like(self, array: Array, dtype: Any | None = None) -> Array: ...
    def linspace(self, start: float, stop: float, num: int, dtype: Any | None = None) -> Array: ...

    # --- Shape Manipulation ---
    def reshape(self, array: Array, shape: tuple[int, ...]) -> Array: ...
    def squeeze(self, array: Array, axis: int | None = None) -> Array: ...
    def transpose(self, array: Array, axes: tuple[int, ...] | None = None) -> Array: ...
    def stack(self, arrays: list[Array], axis: int = 0) -> Array: ...
    def concatenate(self, arrays: list[Array], axis: int = 0) -> Array: ...
    def broadcast_to(self, array: Array, shape: tuple[int, ...]) -> Array: ...

    # --- Reductions ---
    def sum(
        self, array: Array, axis: int | tuple[int, ...] | None = None, keepdims: bool = False
    ) -> Array: ...
    def mean(
        self, array: Array, axis: int | tuple[int, ...] | None = None, keepdims: bool = False
    ) -> Array: ...
    def max(self, array: Array, axis: int | None = None, keepdims: bool = False) -> Array: ...
    def min(self, array: Array, axis: int | None = None, keepdims: bool = False) -> Array: ...
    def argmax(self, array: Array, axis: int | None = None) -> Array: ...
    def argmin(self, array: Array, axis: int | None = None) -> Array: ...
    def var(
        self, array: Array, axis: int | tuple[int, ...] | None = None, keepdims: bool = False
    ) -> Array: ...
    def std(
        self, array: Array, axis: int | tuple[int, ...] | None = None, keepdims: bool = False
    ) -> Array: ...

    # --- Element-wise Operations ---
    def sqrt(self, array: Array) -> Array: ...
    def exp(self, array: Array) -> Array: ...
    def log(self, array: Array) -> Array: ...
    def abs(self, array: Array) -> Array: ...
    def sign(self, array: Array) -> Array: ...
    def maximum(self, lhs: Array, rhs: Array) -> Array: ...
    def minimum(self, lhs: Array, rhs: Array) -> Array: ...
    def clip(
        self, array: Array, min_val: float | Array | None, max_val: float | Array | None
    ) -> Array: ...
    def where(self, condition: Array, x: Array, y: Array) -> Array: ...
    def softmax(self, array: Array, axis: int = -1) -> Array: ...
    def cumsum(self, array: Array, axis: int | None = None) -> Array: ...

    # --- Linear Algebra ---
    def matmul(self, lhs: Array, rhs: Array) -> Array: ...
    def dot(self, a: Array, b: Array) -> Array: ...
    def svd(self, array: Array, compute_uv: bool = True) -> tuple[Array, Array, Array] | Array: ...
    def norm(
        self, array: Array, axis: int | tuple[int, ...] | None = None, keepdims: bool = False
    ) -> Array: ...
    def det(self, array: Array) -> Array: ...
    def eigh(self, array: Array) -> tuple[Array, Array]: ...
    def solve(self, a: Array, b: Array) -> Array: ...
    def qr(self, array: Array) -> tuple[Array, Array]: ...

    # --- Indexing ---
    def take(self, array: Array, indices: Array, axis: int | None = None) -> Array: ...

    # --- Sorting ---
    def sort(self, array: Array, axis: int = -1) -> Array: ...
    def argsort(self, array: Array, axis: int = -1) -> Array: ...
    def argpartition(self, array: Array, kth: int, axis: int = -1) -> Array: ...
    def partition(self, array: Array, kth: int, axis: int = -1) -> Array:
        """Partition array so kth element is in sorted position (O(n) complexity).

        After partitioning, array[kth] equals what it would be in a sorted array.
        Elements before kth are <= array[kth], elements after are >= array[kth].
        Use for efficient percentile computation without full O(n log n) sort.
        """
        ...

    # --- Random ---
    def random_normal(self, shape: tuple[int, ...], dtype: Any | None = None) -> Array: ...
    def random_uniform(
        self,
        low: float = 0.0,
        high: float = 1.0,
        shape: tuple[int, ...] | None = None,
        dtype: Any | None = None,
    ) -> Array: ...
    def random_randint(
        self, low: int, high: int, shape: tuple[int, ...] | None = None
    ) -> Array: ...
    def random_seed(self, seed: int) -> None: ...
    def random_categorical(self, logits: Array, num_samples: int = 1) -> Array:
        """Sample from categorical distribution defined by logits."""
        ...

    # --- Type Conversion ---
    def astype(self, array: Array, dtype: Any) -> Array: ...
    def to_numpy(self, array: Array) -> Any: ...

    # --- Quantization ---
    def quantize(
        self,
        weight: Array,
        group_size: int,
        bits: int,
        mode: str,
    ) -> tuple[Array, Array, Array | None]: ...
    def dequantize(
        self,
        weight: Array,
        scales: Array,
        biases: Array | None,
        group_size: int,
        bits: int,
        mode: str,
    ) -> Array: ...

    # --- Attention Masks ---
    def create_causal_mask(self, seq_len: int, dtype: Any | None = None) -> Array:
        """Create an additive causal attention mask for autoregressive models."""
        ...

    # --- Compute Control ---
    def eval(self, *arrays: Array) -> None: ...
